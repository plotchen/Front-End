# JavaScript基础05

## 昨日回顾

1. **数组**
2. **函数** 

## 今日内容 

1. **作用域、预解析、作用域链**
2. **对象 **{}
3. **内置对象**

#### arguments（知道）

- 函数中内置的对象,是一个**伪**数组
- 不能使用数组的内置方法   但是它有 长度  有下标 可以使用for循环遍历 ,在函数中使用的

### 函数是可以相互调用的（重要！）

```js
function f1() {
console.log(1)
  f2()
  console.log(3)
}

function f2() {
  console.log(2)
  console.log(4)
}
f1()
后期学习 -- 函数是可以自己内部调用自己的；这种方式叫做递归（递归必须有跳出语句）如下：
   function a(n) {
            var m = n;
            m++;
            console.log(m + "-------");
            if (m < 5) {
                a(m);
            }
            console.log(m);
            // 2 3 4 5
        }
        a(1);
```

#### 函数声明方式（重点！）

1. 命名函数

   ```js
   function 函数名(){
       //执行代码
   }
   函数名();
   ```

2. 匿名函数 函数表达式

   ```js
   var fn = function(){
       //执行代码
   }
   fn();
   ```

3. 自调用函数

   ```js
   (function() {
               console.dir('你好世界，我等你好久了');
           })
           (); //执行的意思
   ```


### 作用域（理论--重点理解）

1. **作用**  --  减少变量的命名冲突   使用：当前的变量所作用的范围
2. **分类**
   1. **全局作用域** 全局声明的变量 所有的代码都可以访问
   2. **局部作用域**  只在函数内部能使用
3. 全局变量和局部变量 **☆**
   1. **全局声明的变量是全局变量,作用范围整个页面**   作用的范围是整个window
   2. **局部变量是函数内部声明的变量,只能作用在函数内部**
      1. 在函数内部声明的变量   ----  作用范围就是在函数内部
      2. **函数的形参也是局部变量   ----  作用范围就是在函数内部** 
      3. **在函数内部变量的声明 不加 var   声明到了全局**
   3. 全局变量和局部变量的特点 
      1. **全局变供全局使用,所有的函数  都可以使用, 常驻内存**  
      2. **局部变量 函数调用完成之后 直接销毁**
4. **在es6 之前是没有块级作用域的** -- 块级作用域 { }  

### 作用域链

- 当函数在访问某个变量的时候,会先在自身查找,如果自身没有,就会沿着作用域的范围 一层一层往上查找,形成链式查找 形成了一个作用域链
- 每一个函数function  都有自己的作用域

### 预解析

- **预解析 -- 这个阶段是不进行变量赋值和函数的运行。**

- **js代码在执行的时候有两步, 1预解析 2代码执行**
  - 预解析
    - 变量预解析 
      - 变量提升变量的声明 不提升赋值  (提升   提升到当前作用域最前面)
    - 函数预解析
      - 命名函数  提升函数的声明  不提升函数调用   (提升   提升到当前作用域最前面) 
      - 函数表达式  提升的变量的声明   
- **函数名与变量名冲突的时候 ,优先提升函数的声明 ,其次再提升变量的声明   (函数js中的一等公民)**
- function  A        var  A     

### 对象(重点！)

1. 任何事物都可以看成一个对象,指的是一个具体的事物  存储 属性 和方法   对象是无序键值对的集合  

2. 创建方式

   - 方式一  注意 : 键值对 是以冒号相连 , 属性与属性 或者方法  用 逗号隔开

   ```js
   var BYD = {
     'name': '王可可', 
      age: 5,
      color: 'yellow',
      wang: function(){
        console.log('汪汪汪');
      },
      showFilm: function(){
        console.log('我演的片贼带劲')
      };
   }
   //访问对象中的属性
   	//方式一  BYD.name    
       //方式二 BYD['name']  ---保证中括号中是一个字符串 一定加引号
   //访问方法 BYD.wang()   ----记得加括号调用
   //对象中的属性和方法是可读可写的
   ```

- 方式二   注意  属性与属性 用分号隔开  键值对 赋值用 = 

  ```js
  var  zzl = new Object(); 
  zzl.name = '赵云';
  zzl.waihao = '子龙';
  zzl.home = '常山';
  zzl.say = function(){
    console.log('一肝赤胆平乱世,手中长枪定江山');
  }
  conseole.log(zzl.name)
  zzl.say()
  ```

- 方式三  

  - 原因以上两种创建对象的方式一次只能创建一个对象 利用函数来封装,将对象共有的属性和方法 封装 抽离 到一个函数中   ,这样创建对象就很方便了   这种方式叫做 利用构造函数创建对象 

    ```js
    构造函数的定义方式  ---  之前怎么定义命名函数的 现在就怎么定义构造函数   建议  函数名的首字母大写

      function Dog(sex,color,height,age){
        this.sex = sex
        this.color = color
        this.height = height
        this.age = age
        this.wang = function(arg){
        console.log(arg)
        }
      }

      创建对象
       var dog = new Dog('母','black','70cm',3) //  
       dog.wang()
    ng('wangwang')
       console.log(dog)
       
       1.构造函数的名称 首字母大写 
       2形参和实参一定要对应 
       3 不需要return   
       构造函数中的this 不清楚指向的是谁,只有在new 的时候才能知道  new完之后的this指向的是 new来的实例对象
       
       4 创建对象的时候,new 关键字  new出来的对象我们叫实例对象

    ```
